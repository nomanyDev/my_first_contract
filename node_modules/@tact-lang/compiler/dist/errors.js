"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.throwConstEvalError = exports.throwCompilationError = exports.throwParseError = exports.TactConstEvalError = exports.TactCompilationError = exports.TactParseError = exports.TactError = void 0;
const path_1 = __importDefault(require("path"));
const process_1 = require("process");
const ast_1 = require("./grammar/ast");
class TactError extends Error {
    ref;
    constructor(message, ref) {
        super(message);
        this.ref = ref;
    }
}
exports.TactError = TactError;
class TactParseError extends TactError {
    constructor(message, ref) {
        super(message, ref);
    }
}
exports.TactParseError = TactParseError;
/// This will be split at least into two categories: typechecking and codegen errors
class TactCompilationError extends TactError {
    constructor(message, ref) {
        super(message, ref);
    }
}
exports.TactCompilationError = TactCompilationError;
class TactConstEvalError extends TactCompilationError {
    fatal = false;
    constructor(message, fatal, ref) {
        super(message, ref);
        this.fatal = fatal;
    }
}
exports.TactConstEvalError = TactConstEvalError;
function locationStr(sourceInfo) {
    if (sourceInfo.file) {
        const loc = sourceInfo.interval.getLineAndColumn();
        const file = path_1.default.relative((0, process_1.cwd)(), sourceInfo.file);
        return `${file}:${loc.lineNum}:${loc.colNum}: `;
    }
    else {
        return "";
    }
}
function throwParseError(matchResult, path) {
    const interval = matchResult.getInterval();
    const source = new ast_1.ASTRef(interval, path);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const message = `Parse error: expected ${matchResult.getExpectedText()}\n`;
    throw new TactParseError(`${locationStr(source)}${message}\n${interval.getLineAndColumnMessage()}`, source);
}
exports.throwParseError = throwParseError;
function throwCompilationError(message, source) {
    throw new TactCompilationError(`${locationStr(source)}${message}\n${source.interval.getLineAndColumnMessage()}`, source);
}
exports.throwCompilationError = throwCompilationError;
function throwConstEvalError(message, fatal, source) {
    throw new TactConstEvalError(`${locationStr(source)}${message}\n${source.interval.getLineAndColumnMessage()}`, fatal, source);
}
exports.throwConstEvalError = throwConstEvalError;
