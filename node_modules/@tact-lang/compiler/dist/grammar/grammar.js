"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseImports = exports.parse = void 0;
const grammar_ohm_bundle_1 = __importDefault(require("./grammar.ohm-bundle"));
const ast_1 = require("./ast");
const errors_1 = require("../errors");
const checkVariableName_1 = require("./checkVariableName");
const checkFunctionAttributes_1 = require("./checkFunctionAttributes");
const checkConstAttributes_1 = require("./checkConstAttributes");
let ctx;
// helper to unwrap optional grammar elements (marked with "?")
// ohm-js represents those essentially as lists (IterationNodes)
function unwrapOptNode(optional, f) {
    const optNode = optional.children[0];
    return optNode ? f(optNode) : null;
}
const semantics = grammar_ohm_bundle_1.default.createSemantics();
semantics.addOperation("astOfModule", {
    Module(imports, items) {
        return (0, ast_1.createNode)({
            kind: "program",
            entries: imports.children
                .concat(items.children)
                .map((item) => item.astOfModuleItem()),
        });
    },
});
semantics.addOperation("astOfModuleItem", {
    Import(_importKwd, path, _semicolon) {
        const pathAST = path.astOfExpression();
        if (pathAST.value.indexOf("\\") >= 0) {
            (0, errors_1.throwCompilationError)('Import path can\'t contain "\\"', (0, ast_1.createRef)(path));
        }
        return (0, ast_1.createNode)({
            kind: "program_import",
            path: pathAST,
            ref: (0, ast_1.createRef)(this),
        });
    },
    PrimitiveTypeDecl(_primitive_kwd, type, _semicolon) {
        (0, checkVariableName_1.checkVariableName)(type.sourceString, (0, ast_1.createRef)(type));
        return (0, ast_1.createNode)({
            kind: "primitive",
            origin: ctx.origin,
            name: type.sourceString,
            ref: (0, ast_1.createRef)(this),
        });
    },
    NativeFunctionDecl(_name, _lparen1, funcId, _rparen1, funAttributes, _nativeKwd, tactId, params, _optColon, optReturnType, _semicolon) {
        (0, checkVariableName_1.checkVariableName)(tactId.sourceString, (0, ast_1.createRef)(tactId));
        return (0, ast_1.createNode)({
            kind: "def_native_function",
            origin: ctx.origin,
            attributes: funAttributes.children.map((a) => a.astOfFunctionAttributes()),
            name: tactId.sourceString,
            nativeName: funcId.sourceString,
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            args: params.astsOfList(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StructDecl_regular(_structKwd, typeId, _lbrace, fields, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(typeId.sourceString, (0, ast_1.createRef)(typeId));
        return (0, ast_1.createNode)({
            kind: "def_struct",
            origin: ctx.origin,
            name: typeId.sourceString,
            fields: fields.astsOfList(),
            prefix: null,
            message: false,
            ref: (0, ast_1.createRef)(this),
        });
    },
    StructDecl_message(_messageKwd, _optLparen, optId, _optRparen, typeId, _lbrace, fields, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(typeId.sourceString, (0, ast_1.createRef)(typeId));
        return (0, ast_1.createNode)({
            kind: "def_struct",
            origin: ctx.origin,
            name: typeId.sourceString,
            fields: fields.astsOfList(),
            prefix: unwrapOptNode(optId, (id) => parseInt(id.sourceString)),
            message: true,
            ref: (0, ast_1.createRef)(this),
        });
    },
    Contract(attributes, _contractKwd, contractId, _optWithKwd, optInheritedTraits, _lbrace, contractItems, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(contractId.sourceString, (0, ast_1.createRef)(contractId));
        return (0, ast_1.createNode)({
            kind: "def_contract",
            origin: ctx.origin,
            name: contractId.sourceString,
            attributes: attributes.children.map((ca) => ca.astOfContractAttributes()),
            declarations: contractItems.children.map((item) => item.astOfItem()),
            traits: optInheritedTraits.children[0]?.astsOfList() ?? [],
            ref: (0, ast_1.createRef)(this),
        });
    },
    Trait(attributes, _traitKwd, traitId, _optWithKwd, optInheritedTraits, _lbrace, traitItems, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(traitId.sourceString, (0, ast_1.createRef)(traitId));
        return (0, ast_1.createNode)({
            kind: "def_trait",
            origin: ctx.origin,
            name: traitId.sourceString,
            attributes: attributes.children.map((ca) => ca.astOfContractAttributes()),
            declarations: traitItems.children.map((item) => item.astOfItem()),
            traits: optInheritedTraits.children[0]?.astsOfList() ?? [],
            ref: (0, ast_1.createRef)(this),
        });
    },
    ModuleFunction(fun) {
        return fun.astOfItem();
    },
    ModuleConstant(constant) {
        return constant.astOfItem();
    },
});
// top-level (module-level), contract or trait items:
// constant declarations/definitions, functions, receivers,
// getters, etc.
semantics.addOperation("astOfItem", {
    ConstantDefinition(constAttributes, _constKwd, constId, _colon, constType, _equals, initExpr, _semicolon) {
        const attributes = constAttributes.children.map((a) => a.astOfConstAttribute());
        (0, checkConstAttributes_1.checkConstAttributes)(false, attributes, (0, ast_1.createRef)(this));
        return (0, ast_1.createNode)({
            kind: "def_constant",
            name: constId.sourceString,
            type: constType.astOfType(),
            value: initExpr.astOfExpression(),
            attributes,
            ref: (0, ast_1.createRef)(this),
        });
    },
    ConstantDeclaration(constAttributes, _constKwd, constId, _colon, constType, _semicolon) {
        const attributes = constAttributes.children.map((a) => a.astOfConstAttribute());
        (0, checkConstAttributes_1.checkConstAttributes)(true, attributes, (0, ast_1.createRef)(this));
        return (0, ast_1.createNode)({
            kind: "def_constant",
            name: constId.sourceString,
            type: constType.astOfType(),
            value: null,
            attributes,
            ref: (0, ast_1.createRef)(this),
        });
    },
    StorageVar(fieldDecl, _semicolon) {
        return fieldDecl.astOfDeclaration();
    },
    FunctionDefinition(funAttributes, _funKwd, funId, funParameters, _optColon, optReturnType, _lbrace, funBody, _rbrace) {
        const attributes = funAttributes.children.map((a) => a.astOfFunctionAttributes());
        (0, checkVariableName_1.checkVariableName)(funId.sourceString, (0, ast_1.createRef)(funId));
        (0, checkFunctionAttributes_1.checkFunctionAttributes)(false, attributes, (0, ast_1.createRef)(this));
        return (0, ast_1.createNode)({
            kind: "def_function",
            origin: ctx.origin,
            attributes,
            name: funId.sourceString,
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            args: funParameters.astsOfList(),
            statements: funBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    FunctionDeclaration(funAttributes, _funKwd, funId, funParameters, _optColon, optReturnType, _semicolon) {
        const attributes = funAttributes.children.map((a) => a.astOfFunctionAttributes());
        (0, checkVariableName_1.checkVariableName)(funId.sourceString, (0, ast_1.createRef)(funId));
        (0, checkFunctionAttributes_1.checkFunctionAttributes)(true, attributes, (0, ast_1.createRef)(this));
        return (0, ast_1.createNode)({
            kind: "def_function",
            origin: ctx.origin,
            attributes,
            name: funId.sourceString,
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            args: funParameters.astsOfList(),
            statements: null,
            ref: (0, ast_1.createRef)(this),
        });
    },
    ContractInit(_initKwd, initParameters, _lbrace, initBody, _rbrace) {
        return (0, ast_1.createNode)({
            kind: "def_init_function",
            args: initParameters.astsOfList(),
            statements: initBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    Receiver_regular(_receiveKwd, _lparen, optParameter, _rparen, _lbrace, receiverBody, _rbrace) {
        const optParam = optParameter.children[0];
        const selector = optParam
            ? {
                kind: "internal-simple",
                arg: optParam.astOfDeclaration(),
            }
            : { kind: "internal-fallback" };
        return (0, ast_1.createNode)({
            kind: "def_receive",
            selector,
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    Receiver_comment(_receiveKwd, _lparen, comment, _rparen, _lbrace, receiverBody, _rbrace) {
        return (0, ast_1.createNode)({
            kind: "def_receive",
            selector: {
                kind: "internal-comment",
                comment: comment.astOfExpression(),
            },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    Receiver_bounced(_bouncedKwd, _lparen, parameter, _rparen, _lbrace, receiverBody, _rbrace) {
        return (0, ast_1.createNode)({
            kind: "def_receive",
            selector: { kind: "bounce", arg: parameter.astOfDeclaration() },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    Receiver_externalRegular(_externalKwd, _lparen, optParameter, _rparen, _lbrace, receiverBody, _rbrace) {
        const optParam = optParameter.children[0];
        const selector = optParam
            ? {
                kind: "external-simple",
                arg: optParam.astOfDeclaration(),
            }
            : { kind: "external-fallback" };
        return (0, ast_1.createNode)({
            kind: "def_receive",
            selector,
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    Receiver_externalComment(_externalKwd, _lparen, comment, _rparen, _lbrace, receiverBody, _rbrace) {
        return (0, ast_1.createNode)({
            kind: "def_receive",
            selector: {
                kind: "external-comment",
                comment: comment.astOfExpression(),
            },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
});
semantics.addOperation("astOfFunctionAttributes", {
    FunctionAttribute_getter(_) {
        return { type: "get", ref: (0, ast_1.createRef)(this) };
    },
    FunctionAttribute_extends(_) {
        return { type: "extends", ref: (0, ast_1.createRef)(this) };
    },
    FunctionAttribute_mutates(_) {
        return { type: "mutates", ref: (0, ast_1.createRef)(this) };
    },
    FunctionAttribute_override(_) {
        return { type: "overrides", ref: (0, ast_1.createRef)(this) };
    },
    FunctionAttribute_inline(_) {
        return { type: "inline", ref: (0, ast_1.createRef)(this) };
    },
    FunctionAttribute_virtual(_) {
        return { type: "virtual", ref: (0, ast_1.createRef)(this) };
    },
    FunctionAttribute_abstract(_) {
        return { type: "abstract", ref: (0, ast_1.createRef)(this) };
    },
});
semantics.addOperation("astOfConstAttribute", {
    ConstantAttribute_override(_) {
        return { type: "overrides", ref: (0, ast_1.createRef)(this) };
    },
    ConstantAttribute_virtual(_) {
        return { type: "virtual", ref: (0, ast_1.createRef)(this) };
    },
    ConstantAttribute_abstract(_) {
        return { type: "abstract", ref: (0, ast_1.createRef)(this) };
    },
});
semantics.addOperation("astsOfList", {
    InheritedTraits(traits, _optTrailingComma) {
        return traits
            .asIteration()
            .children.map((id, _comma) => id.astOfExpression());
    },
    StructFields(fields, _optSemicolon) {
        return fields
            .asIteration()
            .children.map((field, _semicolon) => field.astOfDeclaration());
    },
    Parameters(_lparen, params, optTrailingComma, _rparen) {
        if (params.source.contents === "" &&
            optTrailingComma.sourceString === ",") {
            (0, errors_1.throwCompilationError)("Empty parameter list should not have a dangling comma.", (0, ast_1.createRef)(optTrailingComma));
        }
        return params.asIteration().children.map((p) => p.astOfDeclaration());
    },
    Arguments(_lparen, args, optTrailingComma, _rparen) {
        if (args.source.contents === "" &&
            optTrailingComma.sourceString === ",") {
            (0, errors_1.throwCompilationError)("Empty argument list should not have a dangling comma.", (0, ast_1.createRef)(optTrailingComma));
        }
        return args.asIteration().children.map((arg) => arg.astOfExpression());
    },
});
semantics.addOperation("astOfContractAttributes", {
    ContractAttribute_interface(_interface, _lparen, interfaceName, _rparen) {
        return {
            type: "interface",
            name: interfaceName.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        };
    },
});
semantics.addOperation("astOfDeclaration", {
    FieldDecl(id, _colon, type, _optAs, optStorageType, _optEq, optInitializer) {
        return (0, ast_1.createNode)({
            kind: "def_field",
            name: id.sourceString,
            type: type.astOfType(),
            as: unwrapOptNode(optStorageType, (t) => t.sourceString),
            init: unwrapOptNode(optInitializer, (e) => e.astOfExpression()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    Parameter(id, _colon, type) {
        (0, checkVariableName_1.checkVariableName)(id.sourceString, (0, ast_1.createRef)(id));
        return (0, ast_1.createNode)({
            kind: "def_argument",
            name: id.sourceString,
            type: type.astOfType(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StructFieldInitializer_full(fieldId, _colon, initializer) {
        return (0, ast_1.createNode)({
            kind: "new_parameter",
            name: fieldId.sourceString,
            exp: initializer.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StructFieldInitializer_punned(fieldId) {
        return (0, ast_1.createNode)({
            kind: "new_parameter",
            name: fieldId.sourceString,
            exp: fieldId.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
});
// Statements
semantics.addOperation("astOfStatement", {
    // TODO: process StatementBlock
    StatementLet(_letKwd, id, _optColon, optType, _equals, expression, _optSemicolonIfLastStmtInBlock) {
        (0, checkVariableName_1.checkVariableName)(id.sourceString, (0, ast_1.createRef)(id));
        return (0, ast_1.createNode)({
            kind: "statement_let",
            name: id.sourceString,
            type: unwrapOptNode(optType, (t) => t.astOfType()),
            expression: expression.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementReturn(_returnKwd, optExpression, _optSemicolonIfLastStmtInBlock) {
        return (0, ast_1.createNode)({
            kind: "statement_return",
            expression: unwrapOptNode(optExpression, (e) => e.astOfExpression()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementExpression(expression, _optSemicolonIfLastStmtInBlock) {
        return (0, ast_1.createNode)({
            kind: "statement_expression",
            expression: expression.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementAssign(lvalue, operator, expression, _optSemicolonIfLastStmtInBlock) {
        if (operator.sourceString === "=") {
            return (0, ast_1.createNode)({
                kind: "statement_assign",
                path: lvalue.astOfLValue(),
                expression: expression.astOfExpression(),
                ref: (0, ast_1.createRef)(this),
            });
        }
        else {
            let op;
            switch (operator.sourceString) {
                case "+=":
                    op = "+";
                    break;
                case "-=":
                    op = "-";
                    break;
                case "*=":
                    op = "*";
                    break;
                case "/=":
                    op = "/";
                    break;
                case "%=":
                    op = "%";
                    break;
                case "|=":
                    op = "|";
                    break;
                case "&=":
                    op = "&";
                    break;
                case "^=":
                    op = "^";
                    break;
                default:
                    throw "Internal compiler error: unreachable augmented assignment operator. Please report at https://github.com/tact-lang/tact/issues";
            }
            return (0, ast_1.createNode)({
                kind: "statement_augmentedassign",
                path: lvalue.astOfLValue(),
                op,
                expression: expression.astOfExpression(),
                ref: (0, ast_1.createRef)(this),
            });
        }
    },
    StatementCondition_noElse(_ifKwd, condition, _lbrace, thenBlock, _rbrace) {
        return (0, ast_1.createNode)({
            kind: "statement_condition",
            expression: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: null,
            elseif: null,
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementCondition_withElse(_ifKwd, condition, _lbraceThen, thenBlock, _rbraceThen, _elseKwd, _lbraceElse, elseBlock, _rbraceElse) {
        return (0, ast_1.createNode)({
            kind: "statement_condition",
            expression: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: elseBlock.children.map((s) => s.astOfStatement()),
            elseif: null,
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementCondition_withElseIf(_ifKwd, condition, _lbraceThen, thenBlock, _rbraceThen, _elseKwd, elseifClause) {
        return (0, ast_1.createNode)({
            kind: "statement_condition",
            expression: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: null,
            elseif: elseifClause.astOfStatement(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementWhile(_whileKwd, _lparen, condition, _rparen, _lbrace, loopBody, _rbrace) {
        return (0, ast_1.createNode)({
            kind: "statement_while",
            condition: condition.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementRepeat(_repeatKwd, _lparen, iterations, _rparen, _lbrace, loopBody, _rbrace) {
        return (0, ast_1.createNode)({
            kind: "statement_repeat",
            iterations: iterations.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementUntil(_doKwd, _lbrace, loopBody, _rbrace, _untilKwd, _lparen, condition, _rparen, _optSemicolonIfLastStmtInBlock) {
        return (0, ast_1.createNode)({
            kind: "statement_until",
            condition: condition.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementTry_noCatch(_tryKwd, _lbraceTry, tryBlock, _rbraceTry) {
        return (0, ast_1.createNode)({
            kind: "statement_try",
            statements: tryBlock.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementTry_withCatch(_tryKwd, _lbraceTry, tryBlock, _rbraceTry, _catchKwd, _lparen, exitCodeId, _rparen, _lbraceCatch, catchBlock, _rbraceCatch) {
        return (0, ast_1.createNode)({
            kind: "statement_try_catch",
            statements: tryBlock.children.map((s) => s.astOfStatement()),
            catchName: exitCodeId.sourceString,
            catchStatements: catchBlock.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    StatementForEach(_foreachKwd, _lparen, keyId, _comma, valueId, _inKwd, mapId, _rparen, _lbrace, foreachBlock, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(keyId.sourceString, (0, ast_1.createRef)(keyId));
        (0, checkVariableName_1.checkVariableName)(valueId.sourceString, (0, ast_1.createRef)(valueId));
        return (0, ast_1.createNode)({
            kind: "statement_foreach",
            keyName: keyId.sourceString,
            valueName: valueId.sourceString,
            map: mapId.astOfLValue(),
            statements: foreachBlock.children.map((s) => s.astOfStatement()),
            ref: (0, ast_1.createRef)(this),
        });
    },
});
// LValue
semantics.addOperation("astOfLValue", {
    LValue_variable(id) {
        return [
            (0, ast_1.createNode)({
                kind: "lvalue_ref",
                name: id.sourceString,
                ref: (0, ast_1.createRef)(this),
            }),
        ];
    },
    LValue_fieldAccess(id, dot, lvalue) {
        return [
            (0, ast_1.createNode)({
                kind: "lvalue_ref",
                name: id.sourceString,
                ref: (0, ast_1.createRef)(id, dot),
            }),
            ...lvalue.astOfLValue(),
        ];
    },
});
semantics.addOperation("astOfType", {
    // TypeRefs
    Type_optional(typeId, _questionMark) {
        return (0, ast_1.createNode)({
            kind: "type_ref_simple",
            name: typeId.sourceString,
            optional: true,
            ref: (0, ast_1.createRef)(this),
        });
    },
    Type_regular(typeId) {
        return (0, ast_1.createNode)({
            kind: "type_ref_simple",
            name: typeId.sourceString,
            optional: false,
            ref: (0, ast_1.createRef)(this),
        });
    },
    Type_map(_mapKwd, _langle, keyTypeId, _optAsKwdKey, optKeyStorageType, _comma, valueTypeId, _optAsKwdValue, optValueStorageType, _rangle) {
        return (0, ast_1.createNode)({
            kind: "type_ref_map",
            key: keyTypeId.sourceString,
            keyAs: unwrapOptNode(optKeyStorageType, (t) => t.sourceString),
            value: valueTypeId.sourceString,
            valueAs: unwrapOptNode(optValueStorageType, (t) => t.sourceString),
            ref: (0, ast_1.createRef)(this),
        });
    },
    Type_bounced(_bouncedKwd, _langle, typeId, _rangle) {
        return (0, ast_1.createNode)({
            kind: "type_ref_bounced",
            name: typeId.sourceString,
            ref: (0, ast_1.createRef)(this),
        });
    },
});
// Expressions
semantics.addOperation("astOfExpression", {
    // Literals
    integerLiteral(number) {
        return (0, ast_1.createNode)({
            kind: "number",
            value: BigInt(number.sourceString.replaceAll("_", "")),
            ref: (0, ast_1.createRef)(this),
        }); // Parses dec, hex, and bin numbers
    },
    boolLiteral(boolValue) {
        return (0, ast_1.createNode)({
            kind: "boolean",
            value: boolValue.sourceString === "true",
            ref: (0, ast_1.createRef)(this),
        });
    },
    id(firstTactIdCharacter, restOfTactId) {
        return (0, ast_1.createNode)({
            kind: "id",
            value: firstTactIdCharacter.sourceString + restOfTactId.sourceString,
            ref: (0, ast_1.createRef)(this),
        });
    },
    funcId(firstFuncIdCharacter, restOfFuncId) {
        return (0, ast_1.createNode)({
            kind: "id",
            value: firstFuncIdCharacter.sourceString + restOfFuncId.sourceString,
            ref: (0, ast_1.createRef)(this),
        });
    },
    null(_nullKwd) {
        return (0, ast_1.createNode)({ kind: "null", ref: (0, ast_1.createRef)(this) });
    },
    stringLiteral(_startQuotationMark, string, _endQuotationMark) {
        return (0, ast_1.createNode)({
            kind: "string",
            value: string.sourceString,
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionAdd_add(left, _plus, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "+",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionAdd_sub(left, _minus, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "-",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionMul_div(left, _slash, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "/",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionMul_mul(left, _star, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "*",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionMul_rem(left, _percent, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "%",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionEquality_eq(left, _equalsEquals, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "==",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionEquality_not(left, _bangEquals, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "!=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionCompare_gt(left, _rangle, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: ">",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionCompare_gte(left, _rangleEquals, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: ">=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionCompare_lt(left, _langle, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "<",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionCompare_lte(left, _langleEquals, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "<=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionOr_or(left, _pipePipe, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "||",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionAnd_and(left, _ampersandAmpersand, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "&&",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionBitwiseShift_shr(left, _rangleRangle, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: ">>",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionBitwiseShift_shl(left, _langleLangle, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "<<",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionBitwiseAnd_bitwiseAnd(left, _ampersand, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "&",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionBitwiseOr_bitwiseOr(left, _pipe, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "|",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionBitwiseXor_bitwiseXor(left, _caret, right) {
        return (0, ast_1.createNode)({
            kind: "op_binary",
            op: "^",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    // Unary
    ExpressionUnary_plus(_plus, operand) {
        return (0, ast_1.createNode)({
            kind: "op_unary",
            op: "+",
            right: operand.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionUnary_minus(_minus, operand) {
        return (0, ast_1.createNode)({
            kind: "op_unary",
            op: "-",
            right: operand.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionUnary_not(_bang, operand) {
        return (0, ast_1.createNode)({
            kind: "op_unary",
            op: "!",
            right: operand.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionUnary_bitwiseNot(_tilde, operand) {
        return (0, ast_1.createNode)({
            kind: "op_unary",
            op: "~",
            right: operand.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionParens(_lparen, expression, _rparen) {
        return expression.astOfExpression();
    },
    ExpressionUnboxNotNull(operand, _bangBang) {
        return (0, ast_1.createNode)({
            kind: "op_unary",
            op: "!!",
            right: operand.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionFieldAccess(source, _dot, fieldId) {
        return (0, ast_1.createNode)({
            kind: "op_field",
            src: source.astOfExpression(),
            name: fieldId.sourceString,
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionMethodCall(source, _dot, methodId, methodArguments) {
        return (0, ast_1.createNode)({
            kind: "op_call",
            src: source.astOfExpression(),
            name: methodId.sourceString,
            args: methodArguments.astsOfList(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionStaticCall(functionId, functionArguments) {
        return (0, ast_1.createNode)({
            kind: "op_static_call",
            name: functionId.sourceString,
            args: functionArguments.astsOfList(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionStructInstance(typeId, _lbrace, structFields, optTrailingComma, _rbrace) {
        if (structFields.source.contents === "" &&
            optTrailingComma.sourceString === ",") {
            (0, errors_1.throwCompilationError)("Empty parameter list should not have a dangling comma.", (0, ast_1.createRef)(optTrailingComma));
        }
        return (0, ast_1.createNode)({
            kind: "op_new",
            type: typeId.sourceString,
            args: structFields
                .asIteration()
                .children.map((d) => d.astOfDeclaration()),
            ref: (0, ast_1.createRef)(this),
        });
    },
    ExpressionInitOf(_initOfKwd, contractId, initArguments) {
        return (0, ast_1.createNode)({
            kind: "init_of",
            name: contractId.sourceString,
            args: initArguments.astsOfList(),
            ref: (0, ast_1.createRef)(this),
        });
    },
    // Ternary conditional
    ExpressionConditional_ternary(condition, _questionMark, thenExpression, _colon, elseExpression) {
        return (0, ast_1.createNode)({
            kind: "conditional",
            condition: condition.astOfExpression(),
            thenBranch: thenExpression.astOfExpression(),
            elseBranch: elseExpression.astOfExpression(),
            ref: (0, ast_1.createRef)(this),
        });
    },
});
function parse(src, path, origin) {
    return (0, ast_1.inFile)(path, () => {
        const matchResult = grammar_ohm_bundle_1.default.match(src);
        if (matchResult.failed()) {
            (0, errors_1.throwParseError)(matchResult, path);
        }
        ctx = { origin };
        try {
            return semantics(matchResult).astOfModule();
        }
        finally {
            ctx = null;
        }
    });
}
exports.parse = parse;
function parseImports(src, path, origin) {
    const fullAst = parse(src, path, origin);
    return fullAst.entries.flatMap((item) => item.kind === "program_import" ? [item.path.value] : []);
}
exports.parseImports = parseImports;
