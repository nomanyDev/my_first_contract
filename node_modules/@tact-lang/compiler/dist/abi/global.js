"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalFunctions = void 0;
const core_1 = require("@ton/core");
const features_1 = require("../config/features");
const writeConstant_1 = require("../generator/writers/writeConstant");
const writeExpression_1 = require("../generator/writers/writeExpression");
const errors_1 = require("../errors");
const constEval_1 = require("../constEval");
const resolveErrors_1 = require("../types/resolveErrors");
const crypto_1 = require("@ton/crypto");
const path_1 = __importDefault(require("path"));
const process_1 = require("process");
exports.GlobalFunctions = new Map([
    [
        "ton",
        {
            name: "ton",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    (0, errors_1.throwCompilationError)("ton() expects single string argument", ref);
                }
                if (args[0].kind !== "ref") {
                    (0, errors_1.throwCompilationError)("ton() expects single string argument", ref);
                }
                if (args[0].name !== "String") {
                    (0, errors_1.throwCompilationError)("ton() expects single string argument", ref);
                }
                return { kind: "ref", name: "Int", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    (0, errors_1.throwCompilationError)("ton() expects single string argument", ref);
                }
                const str = (0, constEval_1.evalConstantExpression)(resolved[0], ctx.ctx);
                return (0, core_1.toNano)(str).toString(10);
            },
        },
    ],
    [
        "require",
        {
            name: "require",
            resolve: (ctx, args, ref) => {
                if (args.length !== 2) {
                    (0, errors_1.throwCompilationError)("require() expects two arguments", ref);
                }
                if (args[0].kind !== "ref") {
                    (0, errors_1.throwCompilationError)("require() expects first Bool argument", ref);
                }
                if (args[0].name !== "Bool") {
                    (0, errors_1.throwCompilationError)("require() expects first Bool argument", ref);
                }
                if (args[1].kind !== "ref") {
                    (0, errors_1.throwCompilationError)("require() expects second string argument", ref);
                }
                if (args[1].name !== "String") {
                    (0, errors_1.throwCompilationError)("require() expects second string argument", ref);
                }
                return { kind: "void" };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 2) {
                    (0, errors_1.throwCompilationError)("require() expects two arguments", ref);
                }
                const str = (0, constEval_1.evalConstantExpression)(resolved[1], ctx.ctx);
                return `throw_unless(${(0, resolveErrors_1.getErrorId)(str, ctx.ctx)}, ${(0, writeExpression_1.writeExpression)(resolved[0], ctx)})`;
            },
        },
    ],
    [
        "address",
        {
            name: "address",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    (0, errors_1.throwCompilationError)("address() expects one argument", ref);
                }
                if (args[0].kind !== "ref") {
                    (0, errors_1.throwCompilationError)("address() expects string argument", ref);
                }
                if (args[0].name !== "String") {
                    (0, errors_1.throwCompilationError)("address() expects string argument", ref);
                }
                return { kind: "ref", name: "Address", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    (0, errors_1.throwCompilationError)("address() expects one argument", ref);
                }
                const str = (0, constEval_1.evalConstantExpression)(resolved[0], ctx.ctx);
                let address;
                try {
                    address = core_1.Address.parse(str);
                }
                catch {
                    (0, errors_1.throwCompilationError)(`${str} is not a valid address`, ref);
                }
                if (address.workChain !== 0 && address.workChain !== -1) {
                    (0, errors_1.throwCompilationError)(`Address ${str} invalid address`, ref);
                }
                if (!(0, features_1.enabledMasterchain)(ctx.ctx)) {
                    if (address.workChain !== 0) {
                        (0, errors_1.throwCompilationError)(`Address ${str} from masterchain are not enabled for this contract`, ref);
                    }
                }
                // Generate address
                const res = (0, writeConstant_1.writeAddress)(address, ctx);
                ctx.used(res);
                return res + "()";
            },
        },
    ],
    [
        "cell",
        {
            name: "cell",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    (0, errors_1.throwCompilationError)("cell() expects one argument", ref);
                }
                if (args[0].kind !== "ref") {
                    (0, errors_1.throwCompilationError)("cell() expects string argument", ref);
                }
                if (args[0].name !== "String") {
                    (0, errors_1.throwCompilationError)("cell() expects string argument", ref);
                }
                return { kind: "ref", name: "Cell", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    (0, errors_1.throwCompilationError)("cell() expects one argument", ref);
                }
                // Load cell data
                const str = (0, constEval_1.evalConstantExpression)(resolved[0], ctx.ctx);
                let c;
                try {
                    c = core_1.Cell.fromBase64(str);
                }
                catch (e) {
                    (0, errors_1.throwCompilationError)(`Invalid cell ${str}`, ref);
                }
                // Generate address
                const res = (0, writeConstant_1.writeCell)(c, ctx);
                ctx.used(res);
                return `${res}()`;
            },
        },
    ],
    [
        "dump",
        {
            name: "dump",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    (0, errors_1.throwCompilationError)("dump expects 1 argument", ref);
                }
                return { kind: "void" };
            },
            generate: (ctx, args, resolved, ref) => {
                if (!(0, features_1.enabledDebug)(ctx.ctx)) {
                    return `${ctx.used("__tact_nop")}()`;
                }
                const arg = args[0];
                const filePath = ref.file
                    ? path_1.default.relative((0, process_1.cwd)(), ref.file)
                    : "unknown";
                const lineCol = ref.interval.getLineAndColumn();
                const debugPrint = `[DEBUG] File ${filePath}:${lineCol.lineNum}:${lineCol.colNum}`;
                if (arg.kind === "map") {
                    const exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                    return `${ctx.used(`__tact_debug`)}(${exp}, "${debugPrint}")`;
                }
                else if (arg.kind === "null") {
                    return `${ctx.used(`__tact_debug_str`)}("null", "${debugPrint}")`;
                }
                else if (arg.kind === "void") {
                    return `${ctx.used(`__tact_debug_str`)}("void", "${debugPrint}")`;
                }
                else if (arg.kind === "ref") {
                    if (arg.name === "Int") {
                        const exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                        return `${ctx.used(`__tact_debug_str`)}(${ctx.used(`__tact_int_to_string`)}(${exp}), "${debugPrint}")`;
                    }
                    else if (arg.name === "Bool") {
                        const exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                        return `${ctx.used(`__tact_debug_bool`)}(${exp}, "${debugPrint}")`;
                    }
                    else if (arg.name === "String") {
                        const exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                        return `${ctx.used(`__tact_debug_str`)}(${exp}, "${debugPrint}")`;
                    }
                    else if (arg.name === "Address") {
                        const exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                        return `${ctx.used(`__tact_debug_address`)}(${exp}, "${debugPrint}")`;
                    }
                    else if (arg.name === "Builder" ||
                        arg.name === "Slice" ||
                        arg.name === "Cell") {
                        const exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                        return `${ctx.used(`__tact_debug`)}(${exp}, "${debugPrint}")`;
                    }
                    (0, errors_1.throwCompilationError)("dump() not supported for type: " + arg.name, ref);
                }
                else {
                    (0, errors_1.throwCompilationError)("dump() not supported for argument", ref);
                }
            },
        },
    ],
    [
        "dumpStack",
        {
            name: "dumpStack",
            resolve: (_ctx, args, ref) => {
                if (args.length !== 0) {
                    (0, errors_1.throwCompilationError)("dumpStack expects no arguments", ref);
                }
                return { kind: "void" };
            },
            generate: (ctx, _args, _resolved, ref) => {
                if (!(0, features_1.enabledDebug)(ctx.ctx)) {
                    return `${ctx.used("__tact_nop")}()`;
                }
                const filePath = ref.file
                    ? path_1.default.relative((0, process_1.cwd)(), ref.file)
                    : "unknown";
                const lineCol = ref.interval.getLineAndColumn();
                const debugPrint = `[DEBUG] File ${filePath}:${lineCol.lineNum}:${lineCol.colNum}`;
                return `${ctx.used(`__tact_debug_stack`)}("${debugPrint}")`;
            },
        },
    ],
    [
        "emptyMap",
        {
            name: "emptyMap",
            resolve: (ctx, args, ref) => {
                if (args.length !== 0) {
                    (0, errors_1.throwCompilationError)("emptyMap expects no arguments", ref);
                }
                return { kind: "null" };
            },
            generate: (_ctx, _args, _resolved, _ref) => {
                return "null()";
            },
        },
    ],
    [
        "sha256",
        {
            name: "sha256",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    (0, errors_1.throwCompilationError)("sha256 expects 1 argument", ref);
                }
                if (args[0].kind !== "ref") {
                    (0, errors_1.throwCompilationError)("sha256 expects string argument", ref);
                }
                if (args[0].name !== "String" && args[0].name !== "Slice") {
                    (0, errors_1.throwCompilationError)("sha256 expects string or slice argument", ref);
                }
                return { kind: "ref", name: "Int", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (args.length !== 1) {
                    (0, errors_1.throwCompilationError)("sha256 expects 1 argument", ref);
                }
                if (args[0].kind !== "ref") {
                    (0, errors_1.throwCompilationError)("sha256 expects string argument", ref);
                }
                // String case
                if (args[0].name === "String") {
                    try {
                        const str = (0, constEval_1.evalConstantExpression)(resolved[0], ctx.ctx);
                        if (Buffer.from(str).length > 128) {
                            (0, errors_1.throwCompilationError)("sha256 expects string argument with byte length <= 128", ref);
                        }
                        return BigInt("0x" + (0, crypto_1.sha256_sync)(str).toString("hex")).toString(10);
                    }
                    catch (e) {
                        // Not a constant
                    }
                    const exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                    return `string_hash(${exp})`;
                }
                // Slice case
                if (args[0].name === "Slice") {
                    const exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                    return `string_hash(${exp})`;
                }
                (0, errors_1.throwCompilationError)("sha256 expects string or slice argument", ref);
            },
        },
    ],
]);
