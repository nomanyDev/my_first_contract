"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeGetter = exports.writeFunction = exports.writeStatement = exports.unwrapExternal = exports.writeCastedExpression = void 0;
const features_1 = require("../../config/features");
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
const resolveExpression_1 = require("../../types/resolveExpression");
const utils_1 = require("../../utils/utils");
const resolveFuncPrimitive_1 = require("./resolveFuncPrimitive");
const resolveFuncType_1 = require("./resolveFuncType");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
const id_1 = require("./id");
const writeExpression_1 = require("./writeExpression");
const cast_1 = require("./cast");
const resolveFuncTupleType_1 = require("./resolveFuncTupleType");
const ops_1 = require("./ops");
const freshIdentifier_1 = require("./freshIdentifier");
function writeCastedExpression(expression, to, ctx) {
    const expr = (0, resolveExpression_1.getExpType)(ctx.ctx, expression);
    return (0, cast_1.cast)(expr, to, (0, writeExpression_1.writeExpression)(expression, ctx), ctx); // Cast for nullable
}
exports.writeCastedExpression = writeCastedExpression;
function unwrapExternal(targetName, sourceName, type, ctx) {
    if (type.kind === "ref") {
        const t = (0, resolveDescriptors_1.getType)(ctx.ctx, type.name);
        if (t.kind === "struct") {
            if (type.optional) {
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${ops_1.ops.typeFromOptTuple(t.name, ctx)}(${sourceName});`);
            }
            else {
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${ops_1.ops.typeFromTuple(t.name, ctx)}(${sourceName});`);
            }
            return;
        }
        else if (t.kind === "primitive" && t.name === "Address") {
            if (type.optional) {
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = null?(${sourceName}) ? null() : ${ctx.used(`__tact_verify_address`)}(${sourceName});`);
            }
            else {
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${ctx.used(`__tact_verify_address`)}(${sourceName});`);
            }
            return;
        }
    }
    ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${sourceName};`);
}
exports.unwrapExternal = unwrapExternal;
function writeStatement(f, self, returns, ctx) {
    if (f.kind === "statement_return") {
        if (f.expression) {
            // Format expression
            const result = writeCastedExpression(f.expression, returns, ctx);
            // Return
            if (self) {
                ctx.append(`return (${self}, ${result});`);
            }
            else {
                ctx.append(`return ${result};`);
            }
        }
        else {
            if (self) {
                ctx.append(`return (${self}, ());`);
            }
            else {
                ctx.append(`return ();`);
            }
        }
        return;
    }
    else if (f.kind === "statement_let") {
        // Underscore name case
        if (f.name === "_") {
            ctx.append(`${(0, writeExpression_1.writeExpression)(f.expression, ctx)};`);
            return;
        }
        // Contract/struct case
        const t = f.type === null
            ? (0, resolveExpression_1.getExpType)(ctx.ctx, f.expression)
            : (0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, f.type);
        if (t.kind === "ref") {
            const tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
            if (tt.kind === "contract" || tt.kind === "struct") {
                if (t.optional) {
                    ctx.append(`tuple ${(0, id_1.id)(f.name)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                }
                else {
                    ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)(f.name), ctx)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                }
                return;
            }
        }
        ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(t, ctx)} ${(0, id_1.id)(f.name)} = ${writeCastedExpression(f.expression, t, ctx)};`);
        return;
    }
    else if (f.kind === "statement_assign") {
        // Prepare lvalue
        const path = f.path
            .map((v, i) => (i === 0 ? (0, id_1.id)(v.name) : v.name))
            .join(`'`);
        // Contract/struct case
        const t = (0, resolveExpression_1.getExpType)(ctx.ctx, f.path[f.path.length - 1]);
        if (t.kind === "ref") {
            const tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
            if (tt.kind === "contract" || tt.kind === "struct") {
                ctx.append(`${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, `${path}`, ctx)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                return;
            }
        }
        ctx.append(`${path} = ${writeCastedExpression(f.expression, t, ctx)};`);
        return;
    }
    else if (f.kind === "statement_augmentedassign") {
        const path = f.path
            .map((v, i) => (i === 0 ? (0, id_1.id)(v.name) : v.name))
            .join(`'`);
        const t = (0, resolveExpression_1.getExpType)(ctx.ctx, f.path[f.path.length - 1]);
        ctx.append(`${path} = ${(0, cast_1.cast)(t, t, `${path} ${f.op} ${(0, writeExpression_1.writeExpression)(f.expression, ctx)}`, ctx)};`);
        return;
    }
    else if (f.kind === "statement_condition") {
        writeCondition(f, self, false, returns, ctx);
        return;
    }
    else if (f.kind === "statement_expression") {
        const exp = (0, writeExpression_1.writeExpression)(f.expression, ctx);
        ctx.append(`${exp};`);
        return;
    }
    else if (f.kind === "statement_while") {
        ctx.append(`while (${(0, writeExpression_1.writeExpression)(f.condition, ctx)}) {`);
        ctx.inIndent(() => {
            for (const s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
        return;
    }
    else if (f.kind === "statement_until") {
        ctx.append(`do {`);
        ctx.inIndent(() => {
            for (const s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`} until (${(0, writeExpression_1.writeExpression)(f.condition, ctx)});`);
        return;
    }
    else if (f.kind === "statement_repeat") {
        ctx.append(`repeat (${(0, writeExpression_1.writeExpression)(f.iterations, ctx)}) {`);
        ctx.inIndent(() => {
            for (const s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
        return;
    }
    else if (f.kind === "statement_try") {
        ctx.append(`try {`);
        ctx.inIndent(() => {
            for (const s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append("} catch (_) { }");
        return;
    }
    else if (f.kind === "statement_try_catch") {
        ctx.append(`try {`);
        ctx.inIndent(() => {
            for (const s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        if (f.catchName == "_") {
            ctx.append(`} catch (_) {`);
        }
        else {
            ctx.append(`} catch (_, ${(0, id_1.id)(f.catchName)}) {`);
        }
        ctx.inIndent(() => {
            for (const s of f.catchStatements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
        return;
    }
    else if (f.kind === "statement_foreach") {
        // Prepare lvalue
        const path = f.map
            .map((v, i) => (i === 0 ? (0, id_1.id)(v.name) : v.name))
            .join(`'`);
        const t = (0, resolveExpression_1.getExpType)(ctx.ctx, f.map[f.map.length - 1]);
        if (t.kind !== "map") {
            throw Error("Unknown map type");
        }
        const flag = (0, freshIdentifier_1.freshIdentifier)("flag");
        const key = f.keyName == "_" ? (0, freshIdentifier_1.freshIdentifier)("underscore") : (0, id_1.id)(f.keyName);
        const value = f.valueName == "_"
            ? (0, freshIdentifier_1.freshIdentifier)("underscore")
            : (0, id_1.id)(f.valueName);
        // Handle Int key
        if (t.key === "Int") {
            let bits = 257;
            let kind = "int";
            if (t.keyAs && t.keyAs.startsWith("int")) {
                bits = parseInt(t.keyAs.slice(3), 10);
            }
            else if (t.keyAs && t.keyAs.startsWith("uint")) {
                bits = parseInt(t.keyAs.slice(4), 10);
                kind = "uint";
            }
            if (t.value === "Int") {
                let vBits = 257;
                let vKind = "int";
                if (t.valueAs && t.valueAs.startsWith("int")) {
                    vBits = parseInt(t.valueAs.slice(3), 10);
                }
                else if (t.valueAs && t.valueAs.startsWith("uint")) {
                    vBits = parseInt(t.valueAs.slice(4), 10);
                    vKind = "uint";
                }
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_${vKind}`)}(${path}, ${bits}, ${vBits});`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_${vKind}`)}(${path}, ${bits}, ${key}, ${vBits});`);
                });
                ctx.append(`}`);
            }
            else if (t.value === "Bool") {
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_int`)}(${path}, ${bits}, 1);`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_int`)}(${path}, ${bits}, ${key}, 1);`);
                });
                ctx.append(`}`);
            }
            else if (t.value === "Cell") {
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_cell`)}(${path}, ${bits});`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_cell`)}(${path}, ${bits}, ${key});`);
                });
                ctx.append(`}`);
            }
            else if (t.value === "Address") {
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_slice`)}(${path}, ${bits});`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_slice`)}(${path}, ${bits}, ${key});`);
                });
                ctx.append(`}`);
            }
            else {
                // value is struct
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_cell`)}(${path}, ${bits});`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t.value, (0, id_1.id)(f.valueName), ctx)} = ${ops_1.ops.typeNotNull(t.value, ctx)}(${ops_1.ops.readerOpt(t.value, ctx)}(${value}));`);
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_cell`)}(${path}, ${bits}, ${key});`);
                });
                ctx.append(`}`);
            }
        }
        // Handle address key
        if (t.key === "Address") {
            if (t.value === "Int") {
                let vBits = 257;
                let vKind = "int";
                if (t.valueAs && t.valueAs.startsWith("int")) {
                    vBits = parseInt(t.valueAs.slice(3), 10);
                }
                else if (t.valueAs && t.valueAs.startsWith("uint")) {
                    vBits = parseInt(t.valueAs.slice(4), 10);
                    vKind = "uint";
                }
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_${vKind}`)}(${path}, 267, ${vBits});`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_${vKind}`)}(${path}, 267, ${key}, ${vBits});`);
                });
                ctx.append(`}`);
            }
            else if (t.value === "Bool") {
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_int`)}(${path}, 267, 1);`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_int`)}(${path}, 267, ${key}, 1);`);
                });
                ctx.append(`}`);
            }
            else if (t.value === "Cell") {
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_cell`)}(${path}, 267);`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_cell`)}(${path}, 267, ${key});`);
                });
                ctx.append(`}`);
            }
            else if (t.value === "Address") {
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_slice`)}(${path}, 267);`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_slice`)}(${path}, 267, ${key});`);
                });
                ctx.append(`}`);
            }
            else {
                // value is struct
                ctx.append(`var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_cell`)}(${path}, 267);`);
                ctx.append(`while (${flag}) {`);
                ctx.inIndent(() => {
                    ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t.value, (0, id_1.id)(f.valueName), ctx)} = ${ops_1.ops.typeNotNull(t.value, ctx)}(${ops_1.ops.readerOpt(t.value, ctx)}(${value}));`);
                    for (const s of f.statements) {
                        writeStatement(s, self, returns, ctx);
                    }
                    ctx.append(`(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_cell`)}(${path}, 267, ${key});`);
                });
                ctx.append(`}`);
            }
        }
        return;
    }
    throw Error("Unknown statement kind");
}
exports.writeStatement = writeStatement;
function writeCondition(f, self, elseif, returns, ctx) {
    ctx.append(`${elseif ? "} else" : ""}if (${(0, writeExpression_1.writeExpression)(f.expression, ctx)}) {`);
    ctx.inIndent(() => {
        for (const s of f.trueStatements) {
            writeStatement(s, self, returns, ctx);
        }
    });
    if (f.falseStatements && f.falseStatements.length > 0) {
        ctx.append(`} else {`);
        ctx.inIndent(() => {
            for (const s of f.falseStatements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
    }
    else if (f.elseif) {
        writeCondition(f.elseif, self, true, returns, ctx);
    }
    else {
        ctx.append(`}`);
    }
}
function writeFunction(f, ctx) {
    const fd = f.ast;
    // Resolve self
    const self = f.self ? (0, resolveDescriptors_1.getType)(ctx.ctx, f.self) : null;
    // Write function header
    let returns = (0, resolveFuncType_1.resolveFuncType)(f.returns, ctx);
    const returnsOriginal = returns;
    let returnsStr;
    if (self && f.isMutating) {
        if (f.returns.kind !== "void") {
            returns = `(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ${returns})`;
        }
        else {
            returns = `(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ())`;
        }
        returnsStr = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)("self"), ctx);
    }
    // Resolve function descriptor
    const args = [];
    if (self) {
        args.push((0, resolveFuncType_1.resolveFuncType)(self, ctx) + " " + (0, id_1.id)("self"));
    }
    for (const a of f.args) {
        args.push((0, resolveFuncType_1.resolveFuncType)(a.type, ctx) + " " + (0, id_1.id)(a.name));
    }
    // Do not write native functions
    if (f.ast.kind === "def_native_function") {
        if (f.isMutating) {
            // Write same function in non-mutating form
            const nonMutName = ops_1.ops.nonModifying(f.ast.nativeName);
            ctx.fun(nonMutName, () => {
                ctx.signature(`${returnsOriginal} ${nonMutName}(${args.join(", ")})`);
                ctx.flag("impure");
                if ((0, features_1.enabledInline)(ctx.ctx) || f.isInline) {
                    ctx.flag("inline");
                }
                if (f.origin === "stdlib") {
                    ctx.context("stdlib");
                }
                ctx.body(() => {
                    ctx.append(`return ${(0, id_1.id)("self")}~${f.ast.nativeName}(${fd.args
                        .slice(1)
                        .map((arg) => (0, id_1.id)(arg.name))
                        .join(", ")});`);
                });
            });
        }
        return;
    }
    if (fd.kind !== "def_function") {
        // should never happen, just to satisfy typescript
        throw new Error("Unknown function kind");
    }
    const name = self ? ops_1.ops.extension(self.name, f.name) : ops_1.ops.global(f.name);
    // Write function body
    ctx.fun(name, () => {
        ctx.signature(`${returns} ${name}(${args.join(", ")})`);
        ctx.flag("impure");
        if ((0, features_1.enabledInline)(ctx.ctx) || f.isInline) {
            ctx.flag("inline");
        }
        if (f.origin === "stdlib") {
            ctx.context("stdlib");
        }
        ctx.body(() => {
            // Unpack self
            if (self) {
                ctx.append(`var (${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)("self"), ctx)}) = ${(0, id_1.id)("self")};`);
            }
            for (const a of fd.args) {
                if (!(0, resolveFuncPrimitive_1.resolveFuncPrimitive)((0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, a.type), ctx)) {
                    ctx.append(`var (${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)((0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, a.type), (0, id_1.id)(a.name), ctx)}) = ${(0, id_1.id)(a.name)};`);
                }
            }
            // Process statements
            for (const s of fd.statements) {
                writeStatement(s, returnsStr, f.returns, ctx);
            }
            // Auto append return
            if (f.self && f.returns.kind === "void" && f.isMutating) {
                if (fd.statements.length === 0 ||
                    fd.statements[fd.statements.length - 1].kind !==
                        "statement_return") {
                    ctx.append(`return (${returnsStr}, ());`);
                }
            }
        });
    });
    if (f.isMutating) {
        // Write same function in non-mutating form
        const nonMutName = ops_1.ops.nonModifying(name);
        ctx.fun(nonMutName, () => {
            ctx.signature(`${returnsOriginal} ${nonMutName}(${args.join(", ")})`);
            ctx.flag("impure");
            if ((0, features_1.enabledInline)(ctx.ctx) || f.isInline) {
                ctx.flag("inline");
            }
            if (f.origin === "stdlib") {
                ctx.context("stdlib");
            }
            ctx.body(() => {
                ctx.append(`return ${(0, id_1.id)("self")}~${ctx.used(name)}(${fd.args
                    .slice(1)
                    .map((arg) => (0, id_1.id)(arg.name))
                    .join(", ")});`);
            });
        });
    }
}
exports.writeFunction = writeFunction;
function writeGetter(f, ctx) {
    // Render tensors
    const self = f.self ? (0, resolveDescriptors_1.getType)(ctx.ctx, f.self) : null;
    if (!self) {
        throw new Error(`No self type for getter "${f.name}"`); // Impossible
    }
    ctx.append(`_ %${f.name}(${f.args.map((v) => (0, resolveFuncTupleType_1.resolveFuncTupleType)(v.type, ctx) + " " + (0, id_1.id)("$" + v.name)).join(", ")}) method_id(${(0, utils_1.getMethodId)(f.name)}) {`);
    ctx.inIndent(() => {
        // Unpack arguments
        for (const arg of f.args) {
            unwrapExternal((0, id_1.id)(arg.name), (0, id_1.id)("$" + arg.name), arg.type, ctx);
        }
        // Load contract state
        ctx.append(`var self = ${ops_1.ops.contractLoad(self.name, ctx)}();`);
        // Execute get method
        ctx.append(`var res = self~${ctx.used(ops_1.ops.extension(self.name, f.name))}(${f.args.map((v) => (0, id_1.id)(v.name)).join(", ")});`);
        // Pack if needed
        if (f.returns.kind === "ref") {
            const t = (0, resolveDescriptors_1.getType)(ctx.ctx, f.returns.name);
            if (t.kind === "struct") {
                if (f.returns.optional) {
                    ctx.append(`return ${ops_1.ops.typeToOptExternal(t.name, ctx)}(res);`);
                }
                else {
                    ctx.append(`return ${ops_1.ops.typeToExternal(t.name, ctx)}(res);`);
                }
                return;
            }
        }
        // Return result
        ctx.append(`return res;`);
    });
    ctx.append(`}`);
    ctx.append();
}
exports.writeGetter = writeGetter;
