"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeExpression = exports.writeValue = void 0;
const errors_1 = require("../../errors");
const resolveExpression_1 = require("../../types/resolveExpression");
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
const types_1 = require("../../types/types");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
const map_1 = require("../../abi/map");
const global_1 = require("../../abi/global");
const id_1 = require("./id");
const struct_1 = require("../../abi/struct");
const resolveFuncType_1 = require("./resolveFuncType");
const core_1 = require("@ton/core");
const writeConstant_1 = require("./writeConstant");
const ops_1 = require("./ops");
const writeFunction_1 = require("./writeFunction");
const constEval_1 = require("../../constEval");
function isNull(f) {
    return f.kind === "null";
}
function tryExtractPath(f) {
    if (f.kind === "id") {
        return [f.value];
    }
    if (f.kind === "op_field") {
        const p = tryExtractPath(f.src);
        if (p) {
            return [...p, f.name];
        }
        else {
            return null;
        }
    }
    return null;
}
function writeStructConstructor(type, args, ctx) {
    // Check for duplicates
    const name = ops_1.ops.typeConstructor(type.name, args, ctx);
    const renderKey = "$constructor$" + type.name + "$" + args.join(",");
    if (ctx.isRendered(renderKey)) {
        return name;
    }
    ctx.markRendered(renderKey);
    // Generate constructor
    ctx.fun(name, () => {
        const funcType = (0, resolveFuncType_1.resolveFuncType)(type, ctx);
        const sig = `(${funcType}) ${name}(${args.map((v) => (0, resolveFuncType_1.resolveFuncType)(type.fields.find((v2) => v2.name === v).type, ctx) + " " + v).join(", ")})`;
        ctx.signature(sig);
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            // Create expressions
            const expressions = type.fields.map((v) => {
                const arg = args.find((v2) => v2 === v.name);
                if (arg) {
                    return arg;
                }
                else if (v.default !== undefined) {
                    return writeValue(v.default, ctx);
                }
                else {
                    throw Error(`Missing argument for field "${v.name}" in struct "${type.name}"`); // Must not happen
                }
            }, ctx);
            if (expressions.length === 0 && funcType === "tuple") {
                ctx.append(`return empty_tuple();`);
            }
            else {
                ctx.append(`return (${expressions.join(", ")});`);
            }
        });
    });
    return name;
}
function writeValue(val, wCtx) {
    if (typeof val === "bigint") {
        return val.toString(10);
    }
    if (typeof val === "string") {
        const id = (0, writeConstant_1.writeString)(val, wCtx);
        wCtx.used(id);
        return `${id}()`;
    }
    if (typeof val === "boolean") {
        return val ? "true" : "false";
    }
    if (core_1.Address.isAddress(val)) {
        const res = (0, writeConstant_1.writeAddress)(val, wCtx);
        wCtx.used(res);
        return res + "()";
    }
    if (val instanceof core_1.Cell) {
        const res = (0, writeConstant_1.writeCell)(val, wCtx);
        wCtx.used(res);
        return `${res}()`;
    }
    if (val === null) {
        return "null()";
    }
    if (val instanceof types_1.CommentValue) {
        const id = (0, writeConstant_1.writeComment)(val.comment, wCtx);
        wCtx.used(id);
        return `${id}()`;
    }
    if (typeof val === "object" && val !== null && "$tactStruct" in val) {
        // this is a struct value
        const structDescription = (0, resolveDescriptors_1.getType)(wCtx.ctx, val["$tactStruct"]);
        const fields = structDescription.fields.map((field) => field.name);
        const id = writeStructConstructor(structDescription, fields, wCtx);
        wCtx.used(id);
        const fieldValues = structDescription.fields.map((field) => {
            if (field.name in val) {
                return writeValue(val[field.name], wCtx);
            }
            else {
                throw Error(`Struct value is missing a field: ${field.name}`, val);
            }
        });
        return `${id}(${fieldValues.join(", ")})`;
    }
    throw Error("Invalid value", val);
}
exports.writeValue = writeValue;
function writeExpression(f, wCtx) {
    // literals and constant expressions are covered here
    try {
        const value = (0, constEval_1.evalConstantExpression)(f, wCtx.ctx);
        return writeValue(value, wCtx);
    }
    catch (error) {
        if (!(error instanceof errors_1.TactConstEvalError) || error.fatal)
            throw error;
    }
    //
    // ID Reference
    //
    if (f.kind === "id") {
        const t = (0, resolveExpression_1.getExpType)(wCtx.ctx, f);
        // Handle packed type
        if (t.kind === "ref") {
            const tt = (0, resolveDescriptors_1.getType)(wCtx.ctx, t.name);
            if (tt.kind === "contract" || tt.kind === "struct") {
                return (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)(f.value), wCtx);
            }
        }
        if (t.kind === "ref_bounced") {
            const tt = (0, resolveDescriptors_1.getType)(wCtx.ctx, t.name);
            if (tt.kind === "struct") {
                return (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)(f.value), wCtx, false, true);
            }
        }
        // Handle constant
        if ((0, resolveDescriptors_1.hasStaticConstant)(wCtx.ctx, f.value)) {
            const c = (0, resolveDescriptors_1.getStaticConstant)(wCtx.ctx, f.value);
            return writeValue(c.value, wCtx);
        }
        return (0, id_1.id)(f.value);
    }
    // NOTE: We always wrap in parentheses to avoid operator precedence issues
    if (f.kind === "op_binary") {
        // Special case for non-integer types and nullable
        if (f.op === "==" || f.op === "!=") {
            if (isNull(f.left) && isNull(f.right)) {
                if (f.op === "==") {
                    return "true";
                }
                else {
                    return "false";
                }
            }
            else if (isNull(f.left) && !isNull(f.right)) {
                if (f.op === "==") {
                    return `null?(${writeExpression(f.right, wCtx)})`;
                }
                else {
                    return `(~ null?(${writeExpression(f.right, wCtx)}))`;
                }
            }
            else if (!isNull(f.left) && isNull(f.right)) {
                if (f.op === "==") {
                    return `null?(${writeExpression(f.left, wCtx)})`;
                }
                else {
                    return `(~ null?(${writeExpression(f.left, wCtx)}))`;
                }
            }
        }
        // Special case for address
        const lt = (0, resolveExpression_1.getExpType)(wCtx.ctx, f.left);
        const rt = (0, resolveExpression_1.getExpType)(wCtx.ctx, f.right);
        // Case for addresses equality
        if (lt.kind === "ref" &&
            rt.kind === "ref" &&
            lt.name === "Address" &&
            rt.name === "Address") {
            let prefix = "";
            if (f.op == "!=") {
                prefix = "~ ";
            }
            if (lt.optional && rt.optional) {
                wCtx.used(`__tact_slice_eq_bits_nullable`);
                return `( ${prefix}__tact_slice_eq_bits_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)}) )`;
            }
            if (lt.optional && !rt.optional) {
                wCtx.used(`__tact_slice_eq_bits_nullable_one`);
                return `( ${prefix}__tact_slice_eq_bits_nullable_one(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)}) )`;
            }
            if (!lt.optional && rt.optional) {
                wCtx.used(`__tact_slice_eq_bits_nullable_one`);
                return `( ${prefix}__tact_slice_eq_bits_nullable_one(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)}) )`;
            }
            wCtx.used(`__tact_slice_eq_bits`);
            return `( ${prefix}__tact_slice_eq_bits(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)}) )`;
        }
        // Case for cells equality
        if (lt.kind === "ref" &&
            rt.kind === "ref" &&
            lt.name === "Cell" &&
            rt.name === "Cell") {
            const op = f.op === "==" ? "eq" : "neq";
            if (lt.optional && rt.optional) {
                wCtx.used(`__tact_cell_${op}_nullable`);
                return `__tact_cell_${op}_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (lt.optional && !rt.optional) {
                wCtx.used(`__tact_cell_${op}_nullable_one`);
                return `__tact_cell_${op}_nullable_one(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (!lt.optional && rt.optional) {
                wCtx.used(`__tact_cell_${op}_nullable_one`);
                return `__tact_cell_${op}_nullable_one(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
            }
            wCtx.used(`__tact_cell_${op}`);
            return `__tact_cell_${op}(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
        }
        // Case for slices and strings equality
        if (lt.kind === "ref" &&
            rt.kind === "ref" &&
            lt.name === rt.name &&
            (lt.name === "Slice" || lt.name === "String")) {
            const op = f.op === "==" ? "eq" : "neq";
            if (lt.optional && rt.optional) {
                wCtx.used(`__tact_slice_${op}_nullable`);
                return `__tact_slice_${op}_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (lt.optional && !rt.optional) {
                wCtx.used(`__tact_slice_${op}_nullable_one`);
                return `__tact_slice_${op}_nullable_one(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (!lt.optional && rt.optional) {
                wCtx.used(`__tact_slice_${op}_nullable_one`);
                return `__tact_slice_${op}_nullable_one(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
            }
            wCtx.used(`__tact_slice_${op}`);
            return `__tact_slice_${op}(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
        }
        // Case for maps equality
        if (lt.kind === "map" && rt.kind === "map") {
            const op = f.op === "==" ? "eq" : "neq";
            wCtx.used(`__tact_cell_${op}_nullable`);
            return `__tact_cell_${op}_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
        }
        // Check for int or boolean types
        if (lt.kind !== "ref" ||
            rt.kind !== "ref" ||
            (lt.name !== "Int" && lt.name !== "Bool") ||
            (rt.name !== "Int" && rt.name !== "Bool")) {
            const file = f.ref.file;
            const loc_info = f.ref.interval.getLineAndColumn();
            throw Error(`(Internal Compiler Error) Invalid types for binary operation: ${file}:${loc_info.lineNum}:${loc_info.colNum}`); // Should be unreachable
        }
        // Case for ints equality
        if (f.op === "==" || f.op === "!=") {
            const op = f.op === "==" ? "eq" : "neq";
            if (lt.optional && rt.optional) {
                wCtx.used(`__tact_int_${op}_nullable`);
                return `__tact_int_${op}_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (lt.optional && !rt.optional) {
                wCtx.used(`__tact_int_${op}_nullable_one`);
                return `__tact_int_${op}_nullable_one(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (!lt.optional && rt.optional) {
                wCtx.used(`__tact_int_${op}_nullable_one`);
                return `__tact_int_${op}_nullable_one(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
            }
            if (f.op === "==") {
                return `(${writeExpression(f.left, wCtx)} == ${writeExpression(f.right, wCtx)})`;
            }
            else {
                return `(${writeExpression(f.left, wCtx)} != ${writeExpression(f.right, wCtx)})`;
            }
        }
        // Case for "&&" operator
        if (f.op === "&&") {
            return `( (${writeExpression(f.left, wCtx)}) ? (${writeExpression(f.right, wCtx)}) : (false) )`;
        }
        // Case for "||" operator
        if (f.op === "||") {
            return `( (${writeExpression(f.left, wCtx)}) ? (true) : (${writeExpression(f.right, wCtx)}) )`;
        }
        // Other ops
        let op;
        if (f.op === "*") {
            op = "*";
        }
        else if (f.op === "/") {
            op = "/";
        }
        else if (f.op === "%") {
            op = "%";
        }
        else if (f.op === "+") {
            op = "+";
        }
        else if (f.op === "-") {
            op = "-";
        }
        else if (f.op === "<") {
            op = "<";
        }
        else if (f.op === "<=") {
            op = "<=";
        }
        else if (f.op === ">") {
            op = ">";
        }
        else if (f.op === ">=") {
            op = ">=";
        }
        else if (f.op === "<<") {
            op = "<<";
        }
        else if (f.op === ">>") {
            op = ">>";
        }
        else if (f.op === "&") {
            op = "&";
        }
        else if (f.op === "|") {
            op = "|";
        }
        else if (f.op === "^") {
            op = "^";
        }
        else {
            (0, errors_1.throwCompilationError)("Unknown binary operator: " + f.op, f.ref);
        }
        return ("(" +
            writeExpression(f.left, wCtx) +
            " " +
            op +
            " " +
            writeExpression(f.right, wCtx) +
            ")");
    }
    //
    // Unary operations: !, -, +, !!
    // NOTE: We always wrap in parenthesis to avoid operator precedence issues
    //
    if (f.kind === "op_unary") {
        // NOTE: Logical not is written as a bitwise not
        if (f.op === "!") {
            return "(~ " + writeExpression(f.right, wCtx) + ")";
        }
        if (f.op === "~") {
            return "(~ " + writeExpression(f.right, wCtx) + ")";
        }
        if (f.op === "-") {
            return "(- " + writeExpression(f.right, wCtx) + ")";
        }
        if (f.op === "+") {
            return "(+ " + writeExpression(f.right, wCtx) + ")";
        }
        // NOTE: Assert function that ensures that the value is not null
        if (f.op === "!!") {
            const t = (0, resolveExpression_1.getExpType)(wCtx.ctx, f.right);
            if (t.kind === "ref") {
                const tt = (0, resolveDescriptors_1.getType)(wCtx.ctx, t.name);
                if (tt.kind === "struct") {
                    return `${ops_1.ops.typeNotNull(tt.name, wCtx)}(${writeExpression(f.right, wCtx)})`;
                }
            }
            wCtx.used("__tact_not_null");
            return `${wCtx.used("__tact_not_null")}(${writeExpression(f.right, wCtx)})`;
        }
        (0, errors_1.throwCompilationError)("Unknown unary operator: " + f.op, f.ref);
    }
    //
    // Field Access
    // NOTE: this branch resolves "a.b", where "a" is an expression and "b" is a field name
    //
    if (f.kind === "op_field") {
        // Resolve the type of the expression
        const src = (0, resolveExpression_1.getExpType)(wCtx.ctx, f.src);
        if (src === null ||
            ((src.kind !== "ref" || src.optional) && src.kind !== "ref_bounced")) {
            (0, errors_1.throwCompilationError)(`Cannot access field of non-struct type: "${(0, types_1.printTypeRef)(src)}"`, f.ref);
        }
        const srcT = (0, resolveDescriptors_1.getType)(wCtx.ctx, src.name);
        // Resolve field
        let fields;
        fields = srcT.fields;
        if (src.kind === "ref_bounced") {
            fields = fields.slice(0, srcT.partialFieldCount);
        }
        const field = fields.find((v) => v.name === f.name);
        const cst = srcT.constants.find((v) => v.name === f.name);
        if (!field && !cst) {
            (0, errors_1.throwCompilationError)(`Cannot find field "${f.name}" in struct "${srcT.name}"`, f.ref);
        }
        if (field) {
            // Trying to resolve field as a path
            const path = tryExtractPath(f);
            if (path) {
                // Prepare path
                const convertedPath = [];
                convertedPath.push((0, id_1.id)(path[0]));
                convertedPath.push(...path.slice(1));
                const idd = convertedPath.join(`'`);
                // Special case for structs
                if (field.type.kind === "ref") {
                    const ft = (0, resolveDescriptors_1.getType)(wCtx.ctx, field.type.name);
                    if (ft.kind === "struct" || ft.kind === "contract") {
                        return (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(field.type, idd, wCtx);
                    }
                }
                return idd;
            }
            // Getter instead of direct field access
            return `${ops_1.ops.typeField(srcT.name, field.name, wCtx)}(${writeExpression(f.src, wCtx)})`;
        }
        else {
            return writeValue(cst.value, wCtx);
        }
    }
    //
    // Static Function Call
    //
    if (f.kind === "op_static_call") {
        // Check global functions
        if (global_1.GlobalFunctions.has(f.name)) {
            return global_1.GlobalFunctions.get(f.name).generate(wCtx, f.args.map((v) => (0, resolveExpression_1.getExpType)(wCtx.ctx, v)), f.args, f.ref);
        }
        const sf = (0, resolveDescriptors_1.getStaticFunction)(wCtx.ctx, f.name);
        let n = ops_1.ops.global(f.name);
        if (sf.ast.kind === "def_native_function") {
            n = sf.ast.nativeName;
            if (n.startsWith("__tact")) {
                wCtx.used(n);
            }
        }
        else {
            wCtx.used(n);
        }
        return (n +
            "(" +
            f.args
                .map((a, i) => (0, writeFunction_1.writeCastedExpression)(a, sf.args[i].type, wCtx))
                .join(", ") +
            ")");
    }
    //
    // Struct Constructor
    //
    if (f.kind === "op_new") {
        const src = (0, resolveDescriptors_1.getType)(wCtx.ctx, f.type);
        // Write a constructor
        const id = writeStructConstructor(src, f.args.map((v) => v.name), wCtx);
        wCtx.used(id);
        // Write an expression
        const expressions = f.args.map((v) => (0, writeFunction_1.writeCastedExpression)(v.exp, src.fields.find((v2) => v2.name === v.name).type, wCtx), wCtx);
        return `${id}(${expressions.join(", ")})`;
    }
    //
    // Object-based function call
    //
    if (f.kind === "op_call") {
        // Resolve source type
        const src = (0, resolveExpression_1.getExpType)(wCtx.ctx, f.src);
        if (src === null) {
            (0, errors_1.throwCompilationError)(`Cannot call function of non - direct type: "${(0, types_1.printTypeRef)(src)}"`, f.ref);
        }
        // Reference type
        if (src.kind === "ref") {
            if (src.optional) {
                (0, errors_1.throwCompilationError)(`Cannot call function of non - direct type: "${(0, types_1.printTypeRef)(src)}"`, f.ref);
            }
            // Render function call
            const t = (0, resolveDescriptors_1.getType)(wCtx.ctx, src.name);
            // Check struct ABI
            if (t.kind === "struct") {
                if (struct_1.StructFunctions.has(f.name)) {
                    const abi = struct_1.StructFunctions.get(f.name);
                    return abi.generate(wCtx, [src, ...f.args.map((v) => (0, resolveExpression_1.getExpType)(wCtx.ctx, v))], [f.src, ...f.args], f.ref);
                }
            }
            // Resolve function
            const ff = t.functions.get(f.name);
            let name = ops_1.ops.extension(src.name, f.name);
            if (ff.ast.kind === "def_function") {
                wCtx.used(name);
            }
            else {
                name = ff.ast.nativeName;
                if (name.startsWith("__tact")) {
                    wCtx.used(name);
                }
            }
            // Render arguments
            let renderedArguments = f.args.map((a, i) => (0, writeFunction_1.writeCastedExpression)(a, ff.args[i].type, wCtx));
            // Hack to replace a single struct argument to a tensor wrapper since otherwise
            // func would convert (int) type to just int and break mutating functions
            if (ff.isMutating) {
                if (f.args.length === 1) {
                    const t = (0, resolveExpression_1.getExpType)(wCtx.ctx, f.args[0]);
                    if (t.kind === "ref") {
                        const tt = (0, resolveDescriptors_1.getType)(wCtx.ctx, t.name);
                        if ((tt.kind === "contract" || tt.kind === "struct") &&
                            ff.args[0].type.kind === "ref" &&
                            !ff.args[0].type.optional) {
                            renderedArguments = [
                                `${ops_1.ops.typeTensorCast(tt.name, wCtx)}(${renderedArguments[0]})`,
                            ];
                        }
                    }
                }
            }
            // Render
            const s = writeExpression(f.src, wCtx);
            if (ff.isMutating) {
                if (f.src.kind === "id" || f.src.kind === "op_field") {
                    return `${s}~${name}(${renderedArguments.join(", ")})`;
                }
                else {
                    return `${wCtx.used(ops_1.ops.nonModifying(name))}(${[s, ...renderedArguments].join(", ")})`;
                }
            }
            else {
                return `${name}(${[s, ...renderedArguments].join(", ")})`;
            }
        }
        // Map types
        if (src.kind === "map") {
            if (!map_1.MapFunctions.has(f.name)) {
                (0, errors_1.throwCompilationError)(`Map function "${f.name}" not found`, f.ref);
            }
            const abf = map_1.MapFunctions.get(f.name);
            return abf.generate(wCtx, [src, ...f.args.map((v) => (0, resolveExpression_1.getExpType)(wCtx.ctx, v))], [f.src, ...f.args], f.ref);
        }
        if (src.kind === "ref_bounced") {
            throw Error("Unimplemented");
        }
        (0, errors_1.throwCompilationError)(`Cannot call function of non - direct type: "${(0, types_1.printTypeRef)(src)}"`, f.ref);
    }
    //
    // Init of
    //
    if (f.kind === "init_of") {
        const type = (0, resolveDescriptors_1.getType)(wCtx.ctx, f.name);
        return `${ops_1.ops.contractInitChild(f.name, wCtx)}(${["__tact_context_sys", ...f.args.map((a, i) => (0, writeFunction_1.writeCastedExpression)(a, type.init.args[i].type, wCtx))].join(", ")})`;
    }
    //
    // Ternary operator
    //
    if (f.kind === "conditional") {
        return `(${writeExpression(f.condition, wCtx)} ? ${writeExpression(f.thenBranch, wCtx)} : ${writeExpression(f.elseBranch, wCtx)})`;
    }
    //
    // Unreachable
    //
    throw Error("Unknown expression");
}
exports.writeExpression = writeExpression;
